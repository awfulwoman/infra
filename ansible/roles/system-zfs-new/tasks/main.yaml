# ###################################################################
# NOTE: This role only applies ZFS properties on first creation, as
# there's no distinction between mutable and static properties.
# Meh, good enough for now.
# https://support.tools/how-to-create-encrypted-zfs-pool/
# https://github.com/BojanZelic/ansible-zfs-encrypted-datasets/blob/master/tasks/main.yml
# https://arstechnica.com/gadgets/2021/06/a-quick-start-guide-to-openzfs-native-encryption/
# https://github.com/ansible-collections/community.general/issues/4699
# ###################################################################

- name: Ensure ZFS package dependencies exist
  become: true
  ansible.builtin.apt:
    name:
      - zfsutils-linux
      - zfs-zed
      - acl
    state: present

# Testing config stored in <reporoot>/ansible/inventory/host_vars/host-albion/core.yaml
- name: New ZFS config testing
  when: zfs is defined
  block:
    - name: Check status of pools
      ansible.builtin.command:
        cmd: "zpool status {{ item }}"
      register: zpool_check_result
      loop: "{{ zfs | zfs_all_pools }}"
      changed_when: false
      ignore_errors: true

    - name: Address failed pools
      when: zpool_check_result.failed is defined and zpool_check_result.failed
      block:
        - name: Attempt to import pool from block storage device
          ansible.builtin.debug:
            msg: "zpool import {{ item.item }}"
          loop: "{{ zpool_check_result.results | selectattr('rc', '>', 0) | list }}"

        - name: Check status of pools after import attempt
          ansible.builtin.command:
            cmd: "zpool status {{ item }}"
          register: zpool_check_result_import
          loop: "{{ zfs | zfs_all_pools }}"
          changed_when: false
          ignore_errors: true

        - name: From remaining uninitialised pools get those with device specified
          ansible.builtin.debug:
            msg: "zpool create {{ item.item }} - {{ zfs[item.item].device }}"
          when: zfs[item.item].device is defined
          loop: "{{ zpool_check_result_import.results | selectattr('rc', '>', 0) | list }}"
          register: zpool_check_result_create

    - name: Ensure encryption dir exists in /root
      become: true
      ansible.builtin.file:
        dest: "/root/zfs"
        mode: "0644"
        owner: root
        group: root
        state: directory

    - name: Ensure encryption passphrase exists in /root
      become: true
      ansible.builtin.copy:
        content: "{{ vault_zfs_passphrase }}"
        dest: "/root/zfs/passphrase"
        mode: "0640"
        owner: root
        group: root

    # - name: Ensure datasets exist
    #   become: true
    #   ansible.builtin.command:
    #     cmd: >-
    #       zfs create
    #       {% if item.properties is defined %}
    #       {%- for key, value in item.properties.items() -%}
    #       -o {{ key }}={%if value is sameas true or item is sameas false %}{{ value | ternary('on', 'off') }} {% else %}{{ value }} {% endif %}
    #       {%- endfor -%}
    #       {%- endif -%}
    #       {{ item.dataset }}
    #     creates: "/{{ item.dataset }}"
    #   loop: "{{ zfs | zfs_datasets_with_config }}"
    #   register: dataset_creation_result

    - name: Ensure datasets exist
      become: true
      # This role does't cope with trying to apply properties that
      # are static. Hence the Jinja mess below.
      community.general.zfs:
        name: "{{ item.dataset }}"
        state: present
        extra_zfs_properties: "{{ item.properties | default({}) }}"
      loop: "{{ zfs | zfs_datasets_with_config }}"
      register: dataset_creation_result

- name: Ensure zfs-load-key.service exists
  become: true
  ansible.builtin.template:
    src: zfs-load-key.service
    dest: /etc/systemd/system/zfs-load-key.service
    owner: root
    group: root
    mode: "0664"

- name: Ensure zfs-load-key.service  is running
  become: true
  ansible.builtin.systemd_service:
    state: started
    name: zfs-load-key.service
    enabled: true
    no_block: true
